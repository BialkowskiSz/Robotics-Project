#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Sensor, S2,     sonic,          sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

//***	FUNCTION PARAMETERS	***
void right(void);
void left(void);
int begin(int speed, float distance_block);
void back_half_block(int speed, float distance_block);
void scan_1_col(int speed, float distance_block, int *white, int *black);
void forward_block(int speed, float distance_block);
void turn_right(int speed, float distance_block);
void turn_left(int speed, float distance_block);
void forward_2block(int speed, float distance_block);
void scan_whole_row(int speed, float distance_block, int *white, int *black, int columns);
void scan_whole_left(int speed, float distance_block, int *white, int *black, int columns);
void forward_halfblock(int speed, float distance_block);
void travel_whole_row(int speed, float distance_block, int columns);
void writeoutfile(int rows, int columns, int white, int black);

int map[7][9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 				// 0 = White , 1 = Black , 2 = Object , 3 = Start position
									0, 0, 0, 0, 0, 0, 0, 0, 0,
									0, 0, 0, 0, 0, 0, 0, 0, 0,
									0, 0, 0, 0, 0, 0, 0, 0, 0,
									0, 0, 0, 0, 0, 0, 0, 0, 0,
									0, 0, 0, 0, 0, 0, 0, 0, 0,
									0, 0, 0, 0, 0, 0, 0, 0, 0		};

int count_row=0, count_col=0;	//Global counters


task main()
{
	int speed=30;												//Select the speed here
	int i=0;														//Loop counter
	float distance_block = (14 * 22.5);	//Motor encoder value for 1 block (14 can be changed depending on square lenght)
	int rows=7, columns=9;							//Hardcoded variables
	int black=0, white=0, start_pos=0;	//All dynamic variables
	int return_value=0;									//Function return type

	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;	//PID Speed regulation
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;	//PID Speed regulation

	clearTimer(T1);
	nxtDisplayTextLine(0,"Start in 5.");
	waitUntil(time1[T1] > 1000);
	nxtDisplayTextLine(0,"Start in 4.");
	waitUntil(time1[T1] > 2000);
	nxtDisplayTextLine(0,"Start in 3.");
	waitUntil(time1[T1] > 3000);
	nxtDisplayTextLine(0,"Start in 2.");
	waitUntil(time1[T1] > 4000);
	nxtDisplayTextLine(0,"Start in 1.");
	waitUntil(time1[T1] > 5000);
	nxtDisplayTextLine(0,"Executing program.");
	while(return_value == 0)												//While the robot doesn't reach a double line
	{
		return_value = begin(speed, distance_block);	//Begin function travels one block while checking for double line
		start_pos++;																	//Num of blocks travelled up to double line
	}
	turn_right(speed, distance_block);							//Sets up robot to start scanning rows

	for(i=0; i<rows; i++)														//This loop scans the whole grid
	{
		if(i%2 == 0)																	//If row number is even it'll turn right
		{
				scan_whole_row(speed, distance_block, &white, &black, columns);		//Nested function which scans entire row
				turn_right(speed, distance_block);
				forward_2block(speed, distance_block);
				turn_right(speed, distance_block);
	  }
	  else																					//If row number is odd it'll turn left
	  {
	  		scan_whole_left(speed, distance_block, &white, &black, columns);		//Nested function which scans entire row
	  		turn_left(speed, distance_block);
				forward_2block(speed, distance_block);
				turn_left(speed, distance_block);
	  }
	}
	travel_whole_row(speed, distance_block, columns);		//Travels under the start position
	turn_right(speed, distance_block);
	for(i=0; i<((rows-start_pos)+1); i++)								//Travels to start position
	{
		forward_block(speed, distance_block);
	}

	start_pos--;																				//Cannot put (start_pos-1) in line below so I have to do this
	map[start_pos][0] = 3;															//Marks start_pos on the map
	start_pos++;
	writeoutfile(rows, columns, white, black);								//Writes out all the values to the file

	nxtDisplayTextLine(0,"Program finished.");
	wait10Msec(100000);

}//end of main()

//*********************************************************************************************************************************************************************

void scan_whole_row(int speed, float distance_block, int *white, int *black, int columns)
{
	int i;
	count_col=0;
	for(i=0; i<columns; i++)
	{
		scan_1_col(speed, distance_block, white, black);
		count_col++;
	}
	count_row++;

}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void scan_whole_left(int speed, float distance_block, int *white, int *black, int columns)
{
	int i;
	count_col=8;
	for(i=0; i<columns; i++)
	{
		scan_1_col(speed, distance_block, white, black);
		count_col--;
	}
	count_row++;

}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void scan_1_col(int speed, float distance_block, int *white, int *black)
{
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = distance_block;
	nMotorEncoderTarget[motorC] = distance_block;

	if(SensorValue(light) > 40)
		{
				*(white) = *(white) + 1;
		}
	else
		{
				*(black) = *(black) + 1;
				map[count_row][count_col] = 1;
		}
	motor[motorB] = speed;
	motor[motorC] = speed;

	while(nMotorRunState[motorB] != runStateIdle)
	{
		if(SensorValue(light) < 40)
		{
			clearTimer(T1);
			waitUntil(SensorValue(light) > 40 || time1[T1] > 750);
		}
	}

	motor[motorB] = 0;
	motor[motorC] = 0;

}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void travel_whole_row(int speed, float distance_block, int columns)
{
		nMotorEncoder[motorC] = 0;
		nMotorEncoder[motorB] = 0;
		nMotorEncoderTarget[motorB] = (distance_block*columns);
		nMotorEncoderTarget[motorC] = (distance_block*columns);

		motor[motorB] = speed;
		motor[motorC] = speed;

		while(nMotorRunState[motorB] != runStateIdle)
		{}

		motor[motorB] = 0;
		motor[motorC] = 0;
}

//*********************************************************************************************************************************************************************

void turn_left(int speed, float distance_block)
{
	back_half_block(speed, distance_block);
	left();
	back_half_block(speed, distance_block);
}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void forward_halfblock(int speed, float distance_block)
{
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = (distance_block/2)*1;
	nMotorEncoderTarget[motorC] = (distance_block/2)*1;

	motor[motorB] = speed;
	motor[motorC] = speed;

	while(nMotorRunState[motorB] != runStateIdle)
	{}
	motor[motorB] = 0;
	motor[motorC] = 0;
}

//*********************************************************************************************************************************************************************

void forward_2block(int speed, float distance_block)
{
	forward_block(speed, distance_block);
	forward_block(speed, distance_block);
}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void turn_right(int speed, float distance_block)
{
	back_half_block(speed, distance_block);
	right();
	back_half_block(speed, distance_block);
}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void forward_block(int speed, float distance_block)
{
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = distance_block;
	nMotorEncoderTarget[motorC] = distance_block;

	motor[motorB] = speed;
	motor[motorC] = speed;

	while(nMotorRunState[motorB] != runStateIdle)
	{}

	motor[motorB] = 0;
	motor[motorC] = 0;
}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void back_half_block(int speed, float distance_block)
{
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = (distance_block/2)*1;
	nMotorEncoderTarget[motorC] = (distance_block/2)*1;

	motor[motorB] = -1*speed;
	motor[motorC] = -1*speed;

	while(nMotorRunState[motorB] != runStateIdle)
	{}
	motor[motorB] = 0;
	motor[motorC] = 0;
}//END OF FUNCTION

//*********************************************************************************************************************************************************************

int begin(int speed, float distance_block)
{
	int lines=0;

	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	nMotorEncoderTarget[motorB] = distance_block;
	nMotorEncoderTarget[motorC] = distance_block;

	motor[motorB] = speed;
	motor[motorC] = speed;

	while(nMotorRunState[motorB] != runStateIdle)
	{
		if(SensorValue(light) < 40)
		{
			lines++;
			clearTimer(T1);
			waitUntil(SensorValue(light) > 40 || time1[T1] > 1000);
		}
	}

	motor[motorB] = 0;
	motor[motorC] = 0;
	if(lines > 1)
	{
		return(1);
	}
	else
	{
		return(0);
	}
}//END OF FUNCTION

//*********************************************************************************************************************************************************************

void right(void)
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	nMotorEncoderTarget[motorB]= 180;
	nMotorEncoderTarget[motorC]= -180;

	motor[motorB]= -20;
	motor[motorC]= 20;


	while(nMotorRunState[motorB] != runStateIdle)
	{}
	motor[motorA]=0;
	motor[motorB]=0;
}//end of right()

//*********************************************************************************************************************************************************************

void left(void)
{
	nMotorEncoder[motorB]=0;
	nMotorEncoder[motorC]=0;

	nMotorEncoderTarget[motorB]= 180;
	nMotorEncoderTarget[motorC]= -180;

	motor[motorB]= 20;
	motor[motorC]= -20;


	while(nMotorRunState[motorB] != runStateIdle)
	{}
	motor[motorA]=0;
	motor[motorB]=0;
}//end of left()

//*********************************************************************************************************************************************************************

void writeoutfile(int rows, int columns, int white, int black)
{
	int i, j;				//Counters for nested for loops
	string filename = "map_project.dat";
	short N = 2000; //number of bytes to write
 	TFileHandle fp;
	TFileIOResult result;
	OpenWrite(fp, result, filename, N);

	string newline = "\n";
	string string2 = ", ";
  string string1 = "The layout ";
  WriteText(fp, result, string1);
  string1 = "of the map:\n";
  WriteText(fp, result, string1);
  string1 = "White = 0 , Black =";
  WriteText(fp, result, string1);
  string1 = " 1 , Object = 2, ";
  WriteText(fp, result, string1);
  string1 = "Start position = 3.";
  WriteText(fp, result, string1);
  WriteText(fp, result, newline);


  for(i=0; i<rows; i++)
  {
  		for(j=0; j<columns; j++)
  		{
  				string1 = map[i][j];
  				WriteText(fp, result, string1);
  				WriteText(fp, result, string2);
  		}
  		WriteText(fp, result, newline);
	}

	string1 = "Num of rows = ";
	WriteText(fp, result, string1);
	string1 = rows;
	WriteText(fp, result, string1);
	WriteText(fp, result, newline);
	string1 = "Num of columns = ";
	WriteText(fp, result, string1);
	string1 = columns;
	WriteText(fp, result, string1);
	WriteText(fp, result, newline);
	string1 = "Num of white sq = ";
	WriteText(fp, result, string1);
	string1 = white;
	WriteText(fp, result, string1);
	WriteText(fp, result, newline);
	string1 = "Num of black sq = ";
	WriteText(fp, result, string1);
	string1 = black;
	WriteText(fp, result, string1);
	WriteText(fp, result, newline);
	string1 = "Total num of sq = ";
	WriteText(fp, result, string1);
	string1 = (rows*columns);
	WriteText(fp, result, string1);
	WriteText(fp, result, newline);

  // Close the file
  Close(fp, result);

}//END OF FUNCTION
